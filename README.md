# Python-Programming-Notes

## Searching: 탐색
#### 깊이 우선 탐색 (DFS, Depth-First Search)
- 그래프에서 깊은 부분을 우선적으로 탐색
- 데이터 수가 N개이면 O(N) 시간 소요

#### 너비 우선 탐색 (BFS, Breadth Fisrt Search)
- 가까운 노드부터 탐색하는 알고리즘
- 탐색 노드와 인접한 노드를 반복적으로 큐에 넣어 작성

#### 이진 탐색 (Binary Search)
- 배열 내 데이터가 정렬되어 있어야만 사용 가능
- 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 찾는다

## Sorting: 정렬
#### 선택 정렬(Selection Sort)
- 가장 작은 것을 선택해서 맨 앞으로 보내는 것을 반복하여 정렬
- 시간 복잡도 O(N^2)

#### 삽입 정렬 (Insertion Sort)
- 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입
- 데이터가 거의 정렬 되어 있을 때 효율적
- 정렬이 이루어진 원소는 항상 오름차순을 유지
- 시간 복잡도 O(N^2), 거의 정렬된 데이터라면 O(N)

#### 퀵 정렬 (Quick Sort)
- 기준 데이터를 설정하고 그 기준보다 큰 수와 작은 수를 교환하고 리스트를 반으로 나눈다
- 재귀함수 형태로 작성하면 구현이 쉬움, 현재 리스트 길이가 1일 때 종료
- 시간 복잡도 O(NlogN)

## Dynamic Programming
#### 가장 긴 증가하는 부분 수열 (LIS, Longest Increasing Subsequence)
- 부분 수열: 어떤 수열에서 일부 숫자를 지워 만들 수 있는 새로운 수열
- 증가하는 부분 수열: 부분 수열 중 오름차순인 것. 그 중 가장 길이가 긴 수열을 LIS라고 한다  

## Shortest Path: 최단 경로 찾기
#### 다익스트라 알고리즘 (Dijkstra algorithm)
- 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구한다
- 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 찾는 과정을 반복
- 노드 개수가 N, 간선의 개수가 E일 때, 시간복잡도 O(ElogN)

#### 플로이드 워셜 알고리즘 (Floyd-Warshall algorithm)
- 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구한다
- 노드 개수가 N일 때, 시간 복잡도 O(N^3)  

## graph: 그래프 이론
#### 서로소 집합 (union-find)
- 두 집합이 서로소인지 확인
- union 연산이 주어졌을 때 트리 자료 구조를 이용해서 집합을 표현하는 방법:  
  모든 union 연산에 대하여, 다음 { } 을 반복  
  {서로 연결된 두 노드 A, B를 확인한다
   → A와 B의 루트 노드 a, b를 찾아 a를 b의 부모 노드로 설정한다 (a<b일 때) }
     
#### 크루스칼 알고리즘 (Kruskal algorithm)
- 최소 비용으로 만들 수 있는 신장트리를 찾는 대표 알고리즘
- 신장트리란? 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
- 모든 간선 데이터를 비용에 따라 오름차순으로 정렬한 후에, 가장 거리가 짧은 간선부터 집합에 포함시킨다.  
  이 때, 사이클이 발생하는 간선은 집합에 포함시키지 않는다.
  
#### 위상 정렬(Topology Sort)
- 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열
- 순서가 정해져있는 일련의 작업을 차례대로 수행해야 할 때 사용할 수 있다.
- 진입차수가 0인 노드를 큐에 넣고, 큐가 빌 때까지 다음 { }을 반복  
  {큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거 → 새롭게 진입차수가 0이 된 노드를 큐에 넣는다}

## _Reference_  
이것이 코딩테스트다/나동빈/한빛미디어  
